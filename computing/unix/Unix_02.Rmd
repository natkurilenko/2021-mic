
# The Unix Shell: Working with Text

## Text streams

Input and output of most Unix shell programs consists of plain text streams. Text output from a program can be piped into another program, or redirected to other streams. The standard streams are `stdin (0)` (standard input), `stdout (1)` (standard output) and `stderr (2)` (standard error). The default is to assume that input comes from `stdin` and output goes to `stdout`. We can also stream to and from a file. 

## Pipes and redirection

### Creating a text file from command line

For simple file creation, we can just use re-direction

A single `>` will create a new file or over-write an existing one.


```{bash}
echo "1 Hello, {bash}" > hello.txt
```


```{bash}
ls *txt
```

### Appending


```{bash}
echo "2 Hello, again" >> hello.txt
```

#### Special non-printing characters


```{bash}
echo -e "3 Hello\n4 again" >> hello.txt
```

### From file to `stdout


```{bash}
cat hello.txt
```

### Pipe to `cut` program to extract columns 2,3,4,5


```{bash}
cat hello.txt | cut -c 2-5
```

     Hel
     Hel
     Hel
     aga


### Building a chain of pipes

`wc -lc` reports the number of lines and bytes (usually corresponds to characters when using English text). 

Note that character count is 5 per line and not 4 because cut adds a newline character for each line.

#### Extract columns 2-5 and then count the number of lines and characters 


```{bash}
cat hello.txt | cut -c 2-5 | wc -lc  
```

          4      20


#### Extract lines 2-3


```{bash}
cat hello.txt | head -n 3 | tail -n 2
```

### Capturing error messages

The redirection operator > is actually 1> - that is, using stdout. We can also use 2> to redirect the output of stderr. &> means redirect both stdout and stderr, and is useful if for example, you want to direct all output to the same log file for later inspection.


```{bash}
mkdir foo/bar/baz > 'stdout.txt'
```

#### As there is nothing from stdout the file is empty


```{bash}
cat 'stdout.txt'
```

#### We need to use 2> to capture the output from stderr


```{bash}
mkdir foo/bar/baz 2> 'stderr.txt' 
cat 'stderr.txt'
```

### Character substitution with `tr`  (transliteration)

#### Switch case.


```{bash}
echo "gattaca" | tr a-z A-Z
```

#### Find reverse complement of DNA string.


```{bash}
echo 'GATTACA' | tr ACTG TGAC | rev
```

# Working with text

## Create a FASTA file to play with


```{bash}
cat > bgp.fasta << EOF
>HSBGPG Human gene for bone gla protein (BGP)
GGCAGATTCCCCCTAGACCCGCCCGCACCATGGTCAGGCATGCCCCTCCTCATCGCTGGGCACAGCCCAGAGGGT
ATAAACAGTGCTGGAGGCTGGCGGGGCAGGCCAGCTGAGTCCTGAGCAGCAGCCCAGCGCAGCCACCGAGACACC
ATGAGAGCCCTCACACTCCTCGCCCTATTGGCCCTGGCCGCACTTTGCATCGCTGGCCAGGCAGGTGAGTGCCCC
CACCTCCCCTCAGGCCGCATTGCAGTGGGGGCTGAGAGGAGGAAGCACCATGGCCCACCTCTTCTCACCCCTTTG
GCTGGCAGTCCCTTTGCAGTCTAACCACCTTGTTGCAGGCTCAATCCATTTGCCCCAGCTCTGCCCTTGCAGAGG
GAGAGGAGGGAAGAGCAAGCTGCCCGAGACGCAGGGGAAGGAGGATGAGGGCCCTGGGGATGAGCTGGGGTGAAC
CAGGCTCCCTTTCCTTTGCAGGTGCGAAGCCCAGCGGTGCAGAGTCCAGCAAAGGTGCAGGTATGAGGATGGACC
TGATGGGTTCCTGGACCCTCCCCTCTCACCCTGGTCCCTCAGTCTCATTCCCCCACTCCTGCCACCTCCTGTCTG
GCCATCAGGAAGGCCAGCCTGCTCCCCACCTGATCCTCCCAAACCCAGAGCCACCTGATGCCTGCCCCTCTGCTC
CACAGCCTTTGTGTCCAAGCAGGAGGGCAGCGAGGTAGTGAAGAGACCCAGGCGCTACCTGTATCAATGGCTGGG
GTGAGAGAAAAGGCAGAGCTGGGCCAAGGCCCTGCCTCTCCGGGATGGTCTGTGGGGGAGCTGCAGCAGGGAGTG
GCCTCTCTGGGTTGTGGTGGGGGTACAGGCAGCCTGCCCTGGTGGGCACCCTGGAGCCCCATGTGTAGGGAGAGG
AGGGATGGGCATTTTGCACGGGGGCTGATGCCACCACGTCGGGTGTCTCAGAGCCCCAGTCCCCTACCCGGATCC
CCTGGAGCCCAGGAGGGAGGTGTGTGAGCTCAATCCGGACTGTGACGAGTTGGCTGACCACATCGGCTTTCAGGA
GGCCTATCGGCGCTTCTACGGCCCGGTCTAGGGTGTCGCTCTGCTGGCCTGGCCGGCAACCCCAGTTCTGCTCCT
CTCCAGGCACCCTTCTTTCCTCTTCCCCTTGCCCTTGCCCTGACCTCCCAGCCCTATGGATGTGGGGTCCCCATC
ATCCCAGCTGCTCCCAAATAAACTCCAGAAG
EOF
```


```{bash}
wc bgp.fasta
```

## Using regular expresssions


```{bash}
cat bgp.fasta | 
grep "CCCCC"
```

```{bash}
cat bgp.fasta | 
grep -n "CCCCC"
```

```{bash}
cat bgp.fasta |
grep -nv "CCCCC"
```

```{bash}
cat bgp.fasta |
grep "GA*TT.*CA"
```

```{bash}
cat bgp.fasta |
grep -E "^C"
```

```{bash}
cat bgp.fasta |
grep -E "G$"
```

```{bash}
cat bgp.fasta |
grep -E "^C.*G$"
```

```{bash}
cat bgp.fasta |
grep -o "GA*TT.*CA"
```

```{bash}
cat bgp.fasta | 
grep -E "(GCAT)+"
```

```{bash}
cat bgp.fasta | 
grep -Eon "(GCA){2,}"
```

## Transliteration


```{bash}
cat bgp.fasta |
grep -E "^C.*G$" 
```

### Complement


```{bash}
cat bgp.fasta |
grep -E "^C.*G$" |
tr ACTG TAGC
```

### Reverse complement


```{bash}
cat bgp.fasta |
grep -E "^C.*G$" |
tr ACTG TAGC |
rev
```

## Sorting


```{bash}
cat bgp.fasta |
grep -v "^>" |
sort
```

### Sort by default uses lexicographic order


```{bash}
cat bgp.fasta |
grep -nv "^>" |
sort
```

### use `-n` flag for numeric order


```{bash}
cat bgp.fasta |
grep -nv "^>" |
sort -n
```

### Sort descending


```{bash}
cat bgp.fasta |
grep -nv "^>" |
sort -rn
```

## Downloading files


```{bash}
wget ftp://ftp.ensemblgenomes.org/pub/release-39/fungi/gtf/fungi_basidiomycota1_collection/cryptococcus_neoformans_var_grubii_h99/Cryptococcus_neoformans_var_grubii_h99.CNA3.39.gtf.gz
```

```{bash}
ls
```

## File compression/uncompression


```{bash}
ls -lh Cryptococcus_neoformans_var_grubii_h99.CNA3.39.gtf.gz
```

```{bash}
gunzip Cryptococcus_neoformans_var_grubii_h99.CNA3.39.gtf.gz
```


```{bash}
ls -lh
```

## Inspecting the GTF file

A GTF file has some header lines, followed by tabular data in 9 columns:

```
chromosome name > chr{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,X,Y,M}
annotation source > {ENSEMBL,HAVANA}
feature-type > {gene,transcript,exon,CDS,UTR,start_codon,stop_codon,Selenocysteine}
genomic start location > integer-value (1-based)
genomic end location > integer-value
score (not used) > .
genomic strand > {+,-}
genomic phase (for CDS features) > {0,1,2,.}
additional information as key-value pairs > (format: key “value”;)
```


```{bash}
head Cryptococcus_neoformans_var_grubii_h99.CNA3.39.gtf
```

```{bash}
tail Cryptococcus_neoformans_var_grubii_h99.CNA3.39.gtf
```

## Remove comment lines

#### If you know the number of lines


```{bash}
tail +6 Cryptococcus_neoformans_var_grubii_h99.CNA3.39.gtf > Cryptococcus_neoformans_var_grubii_h99.CNA3.39_no_comment.gtf 
head -3 Cryptococcus_neoformans_var_grubii_h99.CNA3.39_no_comment.gtf  
```

#### Using regular expressions (advanced)


```{bash}
cat Cryptococcus_neoformans_var_grubii_h99.CNA3.39.gtf | grep -v '^#' > Cryptococcus_neoformans_var_grubii_h99.CNA3.39_no_comment.gtf 

head -3 Cryptococcus_neoformans_var_grubii_h99.CNA3.39_no_comment.gtf 
```

## Spliting columns


```{bash}
cat Cryptococcus_neoformans_var_grubii_h99.CNA3.39.gtf |
grep -v '^#' |
cut -f3 > Cryptococcus_neoformans_var_grubii_h99.CNA3.39_split.gtf 
head -3 Cryptococcus_neoformans_var_grubii_h99.CNA3.39_split.gtf
```

    gene
    transcript
    exon



```{bash}
cat Cryptococcus_neoformans_var_grubii_h99.CNA3.39.gtf |
grep -v '^#' |
cut -f4-5 > Cryptococcus_neoformans_var_grubii_h99.CNA3.39_split.gtf
head -3 Cryptococcus_neoformans_var_grubii_h99.CNA3.39_split.gtf
```

    100	5645
    100	5645
    5494	5645



```{bash}
cat Cryptococcus_neoformans_var_grubii_h99.CNA3.39.gtf |
grep -v '^#' |
cut -f2,4-5 > Cryptococcus_neoformans_var_grubii_h99.CNA3.39_split.gtf
head -3 Cryptococcus_neoformans_var_grubii_h99.CNA3.39_split.gtf
```

    ena	100	5645
    ena	100	5645
    ena	5494	5645


## Exercises

1. What is the mRNA version of bgp.fasta?


```{bash}

```

2. Extract the nucleotides in positions 5,10 and 15 of each line of bgp.fasta.


```{bash}

```

3. Find the number of mitochondrial exons in the GTF file.


```{bash}

```
# Unix Variables

## Safety - Disable default variables

The default behavior is to assign the empty string to undeclared variables. This is a problem because it makes mis-spelled variables hard to detect.


```{bash}
echo $DOES_NOT_EXIST
```
```{bash}
set -u
```


```{bash}
echo $DOES_NOT_EXIST
```

## Assigning variables


```{bash}
FILENAME="temp.txt"
```


```{bash}
echo $FILENAME
```

```{bash}
echo "Some stuff" > $FILENAME
```


```{bash}
cat $FILENAME
```

## Common mistakes

You must not have spaces on either side of `=` in a variable assignment.


```{bash}
FILENAME = "temp.txt"
```

Unix interprets this as: run a command called `FILENAME`


```{bash}
FILENAME ="temp.txt"
```

Unix interprets this as: Assign space to the variable FILENAME then run a program called `temp.txt`


```{bash}
FILENAME= "temp.txt"
```

## Using a variable


```{bash}
PREFIX="Gene"
```


```{bash}
echo $PREFIX
```

```{bash}
echo $PREFIX001
```

If you surround the variable name with curly braces, you can concatenate names.


```{bash}
echo ${PREFIX}001
```

## Assigning command outputs to variables

To caputre the output of a command, use `$(command)`


```{bash}
FILES=$(ls)
```


```{bash}
echo $FILES
```

```{bash}
grep -in "unix" $FILES | head -5
```

We can also use the anonumous caputre form.


```{bash}
grep -in "unix" $(ls) | head -5
```

You may sometimes see this old backticks form. It is equivalent although modern usage seems to favor the `$(command)` from.


```{bash}
grep -in "unix" `ls` | head -5
```

## Assigning results of  an arithmetic expression (integers only)

To do integer arithmetic, use `$(( expression ))`.


```{bash}
echo $((2 + 3))
```

This does not work for floating point numbers.


```{bash}
echo $((2.2 + 3.3))
```

You need to invoke the `bc` calculator program to deal with floating point numbers.


```{bash}
echo 2.2 + 3.3 | bc 
```

## Using variables in loops


```{bash}
for FILE in $(ls *txt)
do
    wc -c $FILE
done
```

```{bash}
for FIB in 1 1 2 3 5
do
    echo $FIB
done
```

```{bash}
for N in $(seq 1 10)
do
    if [[ $N -le 5 ]]
    then
        echo $N
    else
        echo $((3*N))
    fi
done
```

## Fibonacci series

Just for fun.


```{bash}
a=1
b=1
for i in $(seq 1 10)
do
    echo -n ${a}","
    tmp=$a
    a=$b
    b=$((tmp+b))
done
```

## Single and double quotes

Variables are not evaluated within single quotes, but they are within double quotes.


```{bash}
FOO=42
echo '$FOO'
```

```{bash}
FOO=42
echo "$FOO"
```

### Testing and branching

Simple example - not use of `-lt`, `-gt`, `&&` and use of parentheses within the test `[[ condition ]]`


```{bash}
if [[ (2 -gt 1) && (1 -lt 2)]]
then
    echo '2 > 1'
else
    echo 'WTF?'
fi
```

Check if a file or its uncompressed version exists before downloading.


```{bash}
URL='ftp://ftp.ensemblgenomes.org/pub/release-39/fungi/gtf/fungi_basidiomycota1_collection/cryptococcus_neoformans_var_grubii_h99/Cryptococcus_neoformans_var_grubii_h99.CNA3.39.gtf.gz'

FILENAME=$(basename $URL)
echo ${FILENAME}
echo ${FILENAME%.*}

# Download if file does not exist
if [[ ! ((-f ${FILENAME}) || (-f ${FILENAME%.*}))  ]]
then
    wget $URL
    gunzip $URL
else
    echo "File exists"
fi
```

Using regular expression matching in a test.


```{bash}
for FILE in $(ls)
do
    if [[ $FILE =~ .*Bash.*ipynb$ ]]
    then
        echo $FILE
    fi
done
```

## Environment variables

You can see what variables are visible in the environment with `env`


```{bash}
env | head -5
```

```{bash}
echo $HOME
```

To make a variable visible in the general environment so that other programs can use it, you need to `export` it.


```{bash}
env | grep EXPORTED_VARIABLE
```




```{bash}
export EXPORTED_VARIABLE="Hello, Unix"
```


```{bash}
env | grep EXPORTED_VARIABLE
```

Now remove the environment variable.


```{bash}
unset EXPORTED_VARIABLE
```


```{bash}
env | grep EXPORTED_VARIABLE
```
## Brace expansion

Brace expansions create lists of strings. It can also generate ranges.


```{bash}
echo file.{c,cpp,py,ipynb,csv,txt}
```

```{bash}
echo {a..c}{1..3}.txt
```

```{bash}
for NUM in {1..3}; do
    echo mkdir EXPT-${NUM}
done
```

## Shell scripts

A shell script is just a collection of shell commands that you are now familiar with put into a file that can be executed from the command line. There are a few steps to make a shell script.

1. The first line often contains instructions to use a shell
`#!/bin/{bash}`
2. The other lines contain standard variable declarations, shell commands, loops etc
3. Save the file with the extension (`.sh`)
4. Make the file executable by `chmod +x <FILENAME>.sh`

Now you can run the shell script as though it were a shell command.

### First shell script

Here we will show the mechanics of creating a shell script.

If you know how to use a text editor such as `vi`, `emacs` or `nano`, use it to write `script01.sh` with the following code.

```{bash}
#!/bin/{bash}

echo "Hello {bash}!"
```

If you do not know how to use a text editor, the following will copy the script to the current directory:


```{bash}
cp misc/script01.sh .
```

By default, the file will not be executable.



```{bash}
ls -l script01.sh
```

    -rwxr-xr-x 1 jovyan users 33 Jun 22 19:48 [0m[01;32mscript01.sh[0m


Change permission to make file executable.


```{bash}
chmod +x script01.sh
```


```{bash}
ls -l *sh
```

    -rwxr-xr-x 1 jovyan users  33 Jun 22 19:48 [0m[01;32mscript01.sh[0m
    -rwxr-xr-x 1 jovyan users 384 Jun 22 19:46 [01;32mscript02.sh[0m



```{bash}
./script01.sh
```

    Hello {bash}!


### Second shell script

Here we see how to pass arguments to a script in `script02.sh`

```{bash}
#!/bin/{bash}                                                                     

echo '$# gives $ of arguments     :' $#
echo '$@ gives arguments as array :' $@
echo '$* gives arguments as string:' $*

echo '$1, $2, $3 give first, second, third arguments etc'
echo '$1:' $1
echo '$2:' $2
echo '$2:' $3

echo 'Evaluating "$@"'
for ARG in "$@"
do
    echo ${ARG}
done
echo 'Evaluating "$*"'
for ARG in $*
do
    echo ${ARG}
done


```

Again, if you know how to use an editor, use it to create the script above. If not, just exectute the following to copy it into the current directory.


```{bash}
cp misc/script02.sh .
```


```{bash}
chmod +x script02.sh
```


```{bash}
./script02.sh a b "c d"
```

    $# gives $ of arguments     : 3
    $@ gives arguments as array : a b c d
    $* gives arguments as string: a b c d
    $1, $2, $3 give first, second, third arguments etc
    $1: a
    $2: b
    $2: c d
    Evaluating "$@"
    a
    b
    c d
    Evaluating "$*"
    a
    b
    c
    d


## Exercises

1. Write a shell script that accepts an arbitrary number of filenames as arguments (possibly given by `ls`), and outputs the total number of words in those files.

```{bash}
#!/bin/{bash}

TOTAL=0
for FILE in "$@"
do
    N=$(wc -w < $FILE)
    TOTAL=$((TOTAL + N))
done
echo $TOTAL
```
<!-- #region -->
# The Unix Shell: Programming Constructs


## loops
 
 - **for loops** 
 
    Use for iterating over a fixed number of items (may be unknown at time of coding)
   
    `for i in $( ls ); do`
            echo item: $i
      `done`
        
 - **while loops**
 
     Use for iterating until a certain condition is met
     
    `while true; do`
       echo 'hello' 
      `done`
 
<!-- #endregion -->

### Examples

```{bash}
#This loop lists the files in the current directory and then iterates over them, printing out each filename
for i in $(ls); do
    echo item: $i
done
```

```{bash}
# Why doesn't this work?

for i in $(ls -l); do
    echo item: $i
done
```

```{bash}
for letter in {a,b,c,d}; do
    echo $letter
done
```

```{bash}
# What happens here?

for letter in a,b,c,d; do
    echo $letter
done
```

```{bash}
x=1
while [ $x -le 5 ]
do
  echo "Welcome $x times"
  x=$(( $x + 1 ))
done
```

   WARNING: Beware of infinite loops! They are easy to make with `while` (you can do it with `for` loops too, but `while` is just easier). You 


## Conditionals (sometimes called 'flow control')
  
  - Simple **if-then**
  
 `if [ "foo" = "foo" ]; then`
         echo expression evaluated as true
     `fi`
            
  - **if-then-else**
  
   `if [ "foo" = "foo" ]; then`
               echo expression evaluated as true
    `else`
               echo expression evaluated as false
    `fi`

```{bash}
a=1

if [ $a = 1 ]; then
    echo "a is 1"
fi

```

```{bash}
a=1

if [ $a = 2 ]; then
    echo "a is 2"
else
    echo "a is not 2"
fi
```

```{bash}
a=1
b=2

if [ $a = 2 ] | [ $b = 2 ]; then
    echo "a or b is 2"
fi
```

## Exercises for loops and conditionals

1. Write a for loop to repeat 'hello world' 10 times. Print the number of iteration so the output looks like:
    1. 1 hello world
    2. 2 hello world
    3. 3 hello world 
   
   etc.
 
2. Modify the above to add the word 'again' as many times as the number of current iterations:
   1. 1 hello world
   2. 2 hello world again
   3. 3 hello world again again
   
   etc.
   
3. Modify 2 to stop after 3 iterations, after printing 'enough already'.

4. Modify 3 to use a while loop.

5. Write a conditional statement to check whether a variable is greater than 10 (-gt is greater than) and print "this variable is greater than 10" if it is, or "this variable is not greater than 10" if it is not.

```{bash}

```
