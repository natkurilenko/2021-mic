---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.11.2
  kernelspec:
    display_name: R
    language: R
    name: ir
---

# Bulk RNA-seq: Pathway Analysis

In this workshop, we illustrate how to perform GSEA in R using bulk RNA-seq data. In particular, we focused on using the tool of gene set enrichment analysis (GSEA).

Gene Set Enrichment Analysis (GSEA) was tests whether a set of genes of interest, *e.g.* genes ([Subramanian et al. 2005](https://www.pnas.org/content/102/43/15545)). The software is distributed by the [Broad Institute](https://www.gsea-msigdb.org/gsea/index.jsp) and is freely available for use by academic and non-profit organisations.

GSEA is often slow in implementation. The R package `fgsea` ([Sergushichev 2016](https://www.biorxiv.org/content/10.1101/060012v3)) implements the same algorithm in R [vignette](http://www.bioconductor.org/packages/release/bioc/vignettes/fgsea/inst/doc/fgsea-tutorial.html) “fast preranked gene set enrichment analysis (GSEA)”.


[Commentary on GSEA](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1266131/)


### Example data description

In the study introduced in [Lo 2021](https://pubmed.ncbi.nlm.nih.gov/33597266/) , mice cell line experiments are performend with two experimental factors (2 by 2 factorial design). 

* Treatment (anti-PD1 vs control)
* Cell line (UV2 vs parental)
 
There are three mice per cell line ($n$=12).
 
We will focus the gene level analyses on three analyses

1. GSEA for testing the treatment effect in the two factor additive model

1. GSEA for testing the treatment by cell line interaction

1. GSEA for testing the treatment effect within each of the two cell lines



In general, GSEA follows the following steps:

1. Extract the statistics and the corresponding gene names

1. Map the gene annotations

1. Perform GSEA


### Load library and Data

```{r message=FALSE}
library("DESeq2")
library("ggplot2")
library("tidyverse")
library("fgsea")
library("stringr")
library("biomaRt")
```

### 01 Single gene analysis for testing the treatment effect in the two factor additive model

#### Extract the statistics and the corresponding gene names

Load DDS object for the two-factor additive model

Please review your previous notes on how to generate DDS object and fit an additive model. 

```{r load data}
procdir <- normalizePath("./proc/")
ddsfile <- file.path(procdir, "PRJNA668393-DESeq2-additive.RDS")
dds <- readRDS(ddsfile)
tools::md5sum(ddsfile)
```

Check the meta data. 

```{r}
meta.dat <- colData(dds) %>% as.data.frame
head(meta.dat)
table(meta.dat[,c("cline","trt")])
```

Check the design of the `dds`.

```{r}
design(dds)
```

Obtain the fitting results.

```{r}
res_add <- DESeq2::results(dds, tidy=TRUE)
```

Check the summary of the results.
```{r}
summary(res_add, alpha=0.05)
```
There are in total 28406 genes with nonzero total read count. Only 1 of them is found significantly differentially expressed across two treatments (with adjusted p-value <0.05). Two possible reasons:

* There is indeed very few DE genes.

* The single gene analysis has a small power so that we cannot identify the DE genes.

```{r}
head(res_add)
```
We noticed that some gene statistics are `NA`. This could due to various reasons., *e.g.*, the gene has zero count and thus cannot be used to perform differential expression analysis. Later, we will use these statistics as input for GSEA, so we need to remove those `NA` values.

```{r}
    res_add %>%
    tidyr:: drop_na(stat)  -> res_add
```

Now check the gene ensembl ids. Clearly some of the gene ensembl names contain gene version id. For gene annotation, we need to keep the first part of the name and remove the part after the `.` because two gene names with the same ensemble ids and different id versions represent the same gene. The ensembl names are the stable gene ids.

See more discussions on ensemble ids and version ids can be found [here](https://m.ensembl.org/Help/Faq?id=488).


```{r}
# Find those non-na indices
head(res_add$row)
head(str_remove(res_add$row, ".[0-9][0-9]{0,2}$"))
res_add %>% dplyr::mutate(ensid = str_remove(row, pattern=".[0-9][0-9]{0,2}$")) -> res_add
```

The `pattern` argument of `str_remove` function uses [R regular expressions](https://cran.r-project.org/web/packages/stringr/vignettes/regular-expressions.html).


Plot the ranked fold change.

```{r}
barplot(sort(res_add$stat, decreasing = T))
```

Overall, to extract statistics and gene names, we can use the following codes.

```{r}
    readRDS(ddsfile) %>%
    DESeq2::results(tidy = TRUE) %>%
    tidyr:: drop_na(pvalue) %>%
    dplyr::mutate(ensid = str_remove(row, ".[0-9][0-9]{0,2}$")) -> res_add
```

#### Map the gene annotations

Load the annotation file and pathway file

```{r}
annodir <- "./resource/"
annofile <- file.path(annodir, "Mm.h.all.v7.1.entrez.rds")
mgifile <- file.path(annodir,"MGI_Gene_Model_Coord.rpt")

tools::md5sum(annofile)

Mm.H <- readRDS(annofile)
mgidat <- readr::read_tsv(mgifile)
```

Pre-process the mgi data

```{r}
mgidat %>% 
    dplyr::filter(`6. Entrez gene id` != "null" & `11. Ensembl gene id` != "null") ->
    mgidat
head(mgidat)
```

Check the number of pathway genes not in annotation file
```{r}
length(setdiff(unlist(Mm.H), mgidat[["6. Entrez gene id"]]))
```


```{r}
res_add %>% 
  dplyr::inner_join(mgidat, by = c("ensid" = "11. Ensembl gene id")) %>%
  dplyr::filter(`6. Entrez gene id` %in% unique(unlist(Mm.H))) -> res_add
head(res_add)
```

Pull statistics 

```{r}
res_add %>%
  dplyr::pull(stat, name = "6. Entrez gene id") ->
  ranks
```

#### Perform GSEA

```{r}
set.seed(1234)
fgseaRes <- fgsea(Mm.H, ranks, minSize=15, maxSize = 500)
```
The warning produced indicates that there are few genes that have the same statistics and so are ranked equally. `fgsea` with arbitrarily order determine which comes first in the ranked list. As long as this number is small it shouldn’t significantly effect the results. If the number is large we need to check further.

Usually, when the sample size is smaller, there will be more ties among statistics.

Let's look at the top 10 results.

```{r}
head(fgseaRes[order(padj, -abs(NES)), ], n=10)
```


The [GSEA](https://www.pnas.org/content/102/43/15545.full) paper provided an explanation of the enrichment score plot.

The enrichment score (ES) that reflects the degree to which a set $S$ is overrepresented at the extremes (top or bottom) of the entire ranked list $L$. The score is calculated by walking down the list $L$, increasing a running-sum statistic when we encounter a gene in $S$ and decreasing it when we encounter genes not in $S$. The magnitude of the increment depends on the correlation of the gene with the phenotype. The enrichment score is the maximum deviation from zero encountered in the random walk; it corresponds to a weighted Kolmogorov–Smirnov-like statistic.

```{r}
# not significant

plotEnrichment(Mm.H[["HALLMARK_ESTROGEN_RESPONSE_EARLY"]], ranks)
```

```{r}
# significant
plotEnrichment(Mm.H[["HALLMARK_E2F_TARGETS"]], ranks)
```

#### GSEA Table plot

The function `plotGseaTable`  allows us to plot a summary figure showing the results for multiple pathways.

```{r}
topUp <- fgseaRes %>% filter(ES > 0) %>% top_n(10, wt=-padj)
topDown <- fgseaRes %>% filter(ES < 0) %>% top_n(10, wt=-padj)
topPathways <- bind_rows(topUp, topDown) %>% arrange(-ES)
plot.new()
plotGseaTable(Mm.H[topPathways$pathway], ranks, fgseaRes, gseaParam = 0.5)
```


### 02 GSEA for testing the treatment by cell line interaction

#### Update the DDS object using the model with the `trt` and `cline` interaction

```{r}
procdir <- normalizePath("./proc/")
ddsfile <- file.path(procdir, "PRJNA668393-DESeq2-multiplicative.RDS")
dds <- readRDS(ddsfile)
tools::md5sum(ddsfile)
```
Check the design and the results of DESEQ2 fitting.
```{r}
design(dds)
res_int <- results(dds, tidy=TRUE)
head(res_int)
```

#### Simplified code for GSEA 

```{r}
readRDS(ddsfile) %>%
    DESeq2::results(tidy = TRUE) %>%
    tidyr:: drop_na(stat) %>%
    dplyr::mutate(ensid = str_remove(row, ".[0-9][0-9]{0,2}$")) %>%
    dplyr::inner_join(mgidat, by = c("ensid" = "11. Ensembl gene id")) %>%
    dplyr::filter(`6. Entrez gene id` %in% unique(unlist(Mm.H))) %>% 
    dplyr::pull(stat, name = "6. Entrez gene id") ->
    ranks
```

```{r}
fgseaRes <- fgsea(Mm.H, ranks, minSize=15, maxSize = 500)
head(fgseaRes[order(padj, -abs(NES)), ], n=10)
```

```{r}
plotEnrichment(Mm.H[["HALLMARK_MITOTIC_SPINDLE"]], ranks)
```

```{r}
topUp <- fgseaRes %>% filter(ES > 0) %>% top_n(10, wt=-padj)
topDown <- fgseaRes %>% filter(ES < 0) %>% top_n(10, wt=-padj)
topPathways <- bind_rows(topUp, topDown) %>% arrange(-ES)
plot.new()
plotGseaTable(Mm.H[topPathways$pathway], ranks, fgseaRes, gseaParam = 0.5)
```

### 03 GSEA for testing the treatment effect within each of the two cell lines

#### Define the model matrix

```{r}
mod_mat <- model.matrix(design(dds), colData(dds))
mod_mat
```

#### Extract the data in the cell line "Parental"

```{r}
head(meta.dat)
table(meta.dat[,c("trt","cline")])
parental_isotype <- colMeans(mod_mat[(dds$cline =="Parental")&(dds$trt=="isotype"),])
parental_antipd1 <- colMeans(mod_mat[(dds$cline =="Parental")&(dds$trt=="antiPD1"),])
```

#### An alternative way to specify constrast and extract estimator of effect size

See this [tutorial](https://github.com/tavareshugo/tutorial_DESeq2_contrasts) for more details on how to define contrasts.

```{r}
res_trt_pa <- results(dds, contrast = parental_antipd1 - parental_isotype)
plot(res_trt_pa$log2FoldChange)
```


```{r}
head(res_trt_pa)
```

#### Homework: 

Please follow the above examples and finish the GSEA by yourself.
Keep in mind the three key steps.

1. Extract the statistics and the corresponding gene names

1. Map the gene annotations

1. Perform GSEA
